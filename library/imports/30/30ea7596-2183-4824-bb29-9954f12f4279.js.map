{"version":3,"sources":["../../../../../assets/script/cut2/assets/script/cut2/cut-main2.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"../../../../../assets/script/cut2","sourcesContent":["import Item from \"./cut-item2\";\n\nconst {ccclass, property} = cc._decorator;\n\n@ccclass\nexport default class Main extends cc.Component {\n\n    @property(cc.Graphics)\n    draw: cc.Graphics = undefined;\n\n    @property(cc.Node)\n    gameLayer: cc.Node = undefined;\n\n    onLoad () {\n        this.registerEvent();\n    }\n\n    registerEvent () {\n        this.node.on(cc.Node.EventType.TOUCH_MOVE, (e) => {\n            this.draw.clear();\n            const startPoint = e.getStartLocation();\n            this.draw.moveTo(startPoint.x, startPoint.y);\n            this.draw.lineTo(e.getLocationX(), e.getLocationY());\n            this.draw.stroke();\n        }, this);\n\n        this.node.on(cc.Node.EventType.TOUCH_END, (e) => {\n            this.draw.clear();\n            const p1 = e.getStartLocation();\n            const p2 = e.getLocation();\n            this.cut(p1, p2);\n        }, this);\n    }\n\n    cut (point1, point2) {\n        const result1 = cc.director.getPhysicsManager().rayCast(point1, point2, cc.RayCastType.All);\n        const result2 = cc.director.getPhysicsManager().rayCast(point2, point1, cc.RayCastType.All);\n        // 将结果二的方向反过来，方便排序\n        result2.forEach(r => {\n            r.fraction = 1 - r.fraction;\n        });\n        // 将结果合并\n        const results = result1.concat(result2);\n        // cc.log(results);\n        // 然后我们将结果按碰撞体进行分类\n        let pairs = [];\n        for (let i = 0; i < results.length; i++) {\n            let find = false;\n            let result = results[i];\n            for (let j = 0; j < pairs.length; j++) {\n                let pair = pairs[j];\n                // 以第一个点为参考，如果碰撞盒子是同一个，证明是一个物体\n                if (pair[0] && result.collider === pair[0].collider) {\n                    find = true;\n                    // 移除同碰撞体内部的多余的点，成对位置相等（很近）\n                    let r = pair.find((r) => {\n                        // 官方取的判断临界是根号 5，很小的距离来判断点的相等\n                        return r.point.sub(result.point).magSqr() <= 5;\n                    });\n                    // 如果有非常近的点，跳过 push，然后把里面的删去\n                    if (r) {\n                        pair.splice(pair.indexOf(r), 1);\n                    }\n                    else { \n                        pair.push(result);\n                    }\n                    break;\n                }\n            }\n            if (!find) {\n                pairs.push([result]);\n            }\n        }\n        // cc.log(pairs);\n        // 接下来就是把每个碰撞体的点分别处理\n        for (let i = 0; i < pairs.length; i++) {\n            let pair = pairs[i];\n            if (pair.length < 2) {\n                continue;\n            }\n            // 根据远近，按顺序排队，这样每两个一组，不重复\n            pair = pair.sort((a, b) => {\n                if (a.fraction > b.fraction) {\n                    return 1;\n                } else if (a.fraction < b.fraction) {\n                    return -1;\n                }\n                return 0;\n            });\n            // cc.log(pair)\n            // 将一个碰撞体上的所有点分成几个部分，比如两个交点就是两部分，四个交点就可能需要分成三部分\n            let splitResults = [];\n            // 每两个点一循环\n            for (let j = 0; j < pair.length - 1; j+=2) {\n                let r1 = pair[j];\n                let r2 = pair[j+1];\n                if (r1 && r2) {\n                    // 封装一个方法，将分割后的结果放入 splitResults 中\n                    this.split(r1.collider, r1.point, r2.point, splitResults);\n                }\n            }\n            if (splitResults.length <= 0) {\n                continue;\n            }\n            // 根据结果创建碰撞体\n            let collider = pair[0].collider;\n            let maxPointsResult;\n            for (let j = 0; j < splitResults.length; j++) {\n                let splitResult = splitResults[j];\n                for (let k = 0; k < splitResult.length; k++) {\n                    if (typeof splitResult[k] === 'number') {\n                        splitResult[k] = collider.points[splitResult[k]];\n                    }\n                }\n                if (!maxPointsResult || splitResult.length > maxPointsResult.length) {\n                    maxPointsResult = splitResult;\n                }\n            }\n            // 分割结果不构成图形\n            if (maxPointsResult.length < 3) {\n                continue;\n            }\n            // 设置本体\n            collider.points = maxPointsResult;\n            collider.apply();\n            collider.node.getComponent(Item).draw();\n            // 克隆 N 个\n            for (let j = 0; j < splitResults.length; j++) {\n                let splitResult = splitResults[j];\n                if (splitResult.length < 3) continue;\n                if (splitResult == maxPointsResult) continue;\n                // 克隆本体作为第 N 个\n                const cloneNode = cc.instantiate(collider.node);\n                this.gameLayer.addChild(cloneNode);\n                const comp = cloneNode.getComponent(cc.PhysicsPolygonCollider);\n                comp.points = splitResult;\n                comp.apply();\n                cloneNode.getComponent(Item).draw();\n            }\n            \n        }\n    }\n\n    split (collider, point1, point2, splitResults) {\n        let body = collider.body;\n        let points = collider.points;\n        // 转化为本地坐标\n        let localPoint1 = cc.Vec2.ZERO;\n        let localPoint2 = cc.Vec2.ZERO;\n        body.getLocalPoint(point1, localPoint1);\n        body.getLocalPoint(point2, localPoint2);\n        let newSplitResult1 = [localPoint1, localPoint2];\n        let newSplitResult2 = [localPoint2, localPoint1];\n        // 同教程第一部分，寻找下标\n        let index1 = undefined;\n        let index2 = undefined;\n        for (let i = 0; i < points.length; i++) {\n            let p1 = points[i];\n            let p2 = i === points.length - 1 ? points[0] : points[i + 1];\n            if (this.pointInLine(localPoint1, p1, p2)) {\n                index1 = i;\n            }\n            if (this.pointInLine(localPoint2, p1, p2)) {\n                index2 = i;\n            }\n            if (index1 !== undefined && index2 !== undefined) {\n                break;\n            }\n        }\n        // cc.log(`点1下标${index1}`);\n        // cc.log(`点2下标${index2}`);\n        let splitResult = undefined;\n        let indiceIndex1 = index1;\n        let indiceIndex2 = index2;\n        // 检测重叠部分，如果有重叠部分，证明有另外一部分属于新的碰撞体，将其切割出来\n        if (splitResults.length > 0) {\n            for (let i = 0; i < splitResults.length; i++) {\n                let indices = splitResults[i];\n                indiceIndex1 = indices.indexOf(index1);\n                indiceIndex2 = indices.indexOf(index2);\n                if (indiceIndex1 !== -1 && indiceIndex2 !== -1) {\n                    splitResult = splitResults.splice(i, 1)[0];\n                    break;\n                }\n            }\n        }\n        // 如果没有重叠，可以将碰撞体所有点装入\n        if (!splitResult) {\n            splitResult = points.map((p, i) => {\n                return i;\n            });\n        }\n        // 分割开两部分，不同于教程一的变量控制做法，这次利用循环走一圈，走到点 2，再从点 2 往点 1 走\n        for (let i = indiceIndex1 + 1; i !== (indiceIndex2+1); i++) {\n            if (i >= splitResult.length) {\n                i = 0;\n            }\n            let p = splitResult[i];\n            // 如果是下标，读数组\n            p = typeof p === 'number' ? points[p] : p;\n            if (p.sub(localPoint1).magSqr() < 5 || p.sub(localPoint2).magSqr() < 5) {\n                continue;\n            }\n            newSplitResult2.push(splitResult[i]);\n        }\n        for (let i = indiceIndex2 + 1; i !== indiceIndex1+1; i++) {\n            if (i >= splitResult.length) {\n                i = 0;\n            }\n            let p = splitResult[i];\n            p = typeof p === 'number' ? points[p] : p;\n            if (p.sub(localPoint1).magSqr() < 5 || p.sub(localPoint2).magSqr() < 5) {\n                continue;\n            }\n            newSplitResult1.push(splitResult[i]);\n        }\n        // 两个方向遍历完毕，装入结果\n        splitResults.push(newSplitResult1);\n        splitResults.push(newSplitResult2);\n    }\n\n    /** 近似判断点在线上 */\n    pointInLine (point, start, end) {\n        const dis = 1;\n        return cc.Intersection.pointLineDistance(point, start, end, true) < dis;\n    }\n\n}\n"]}